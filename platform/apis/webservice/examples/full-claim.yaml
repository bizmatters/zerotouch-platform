# Full-Featured WebService Claim
#
# This example demonstrates all available features including:
# - PostgreSQL database provisioning
# - External HTTPS ingress via HTTPRoute
# - Multiple secrets from different sources
# - Init container for database migrations
# - Private container registry with image pull secrets
# - Medium resource allocation

apiVersion: platform.bizmatters.io/v1alpha1
kind: WebService
metadata:
  name: full-featured-web-service
  namespace: production
spec:
  # Container configuration
  image: "ghcr.io/org/my-web-service:v1.2.3"
  port: 8080
  size: medium
  replicas: 3
  
  # Database configuration
  databaseName: "my_web_service"
  databaseSize: medium
  
  # All secrets are mounted via envFrom (bulk mounting - all keys become environment variables)
  
  # Secret 1: Database credentials (auto-generated by PostgresInstance)
  # Created automatically with name: full-featured-web-service-db-conn
  # Keys: endpoint, port, database, username, password
  secret1Name: full-featured-web-service-db-conn
  
  # Secret 2: JWT signing keys (External Secrets Operator)
  # Keys: jwt_private_key, jwt_public_key, jwt_issuer
  secret2Name: full-featured-web-service-jwt-keys
  
  # Secret 3: Application secrets (External Secrets Operator)
  # Keys: api_key, webhook_secret, encryption_key
  secret3Name: full-featured-web-service-app-secrets
  
  # Image pull secrets for private registry
  imagePullSecrets:
    - name: ghcr-pull-secret
  
  # Init container for database migrations
  # Runs before main container starts
  # Uses same image as main container
  # Has access to same secrets (database credentials available)
  initContainer:
    command: ["/bin/bash", "-c"]
    args:
      - |
        echo "Running database migrations..."
        cd /app && ./scripts/ci/run-migrations.sh
        echo "Migrations completed successfully"
  
  # External ingress configuration
  hostname: "api.bizmatters.com"
  pathPrefix: "/v1"
  
  # Custom health check paths
  healthPath: "/health"
  readyPath: "/ready"

# This creates:
# - ServiceAccount: full-featured-web-service
# - PostgresInstance: full-featured-web-service-db (medium size, auto-generates secret)
# - Deployment: full-featured-web-service (3 replicas, medium resources, init container)
# - Service: full-featured-web-service (ClusterIP, port 8080)
# - HTTPRoute: full-featured-web-service (external access via api.bizmatters.com/v1)

# Environment Variables Available in Container:
# From secret1Name (database):
#   - endpoint, port, database, username, password
# From secret2Name (JWT):
#   - jwt_private_key, jwt_public_key, jwt_issuer
# From secret3Name (app):
#   - api_key, webhook_secret, encryption_key

# External Access:
# - HTTPS: https://api.bizmatters.com/v1
# - Internal: http://full-featured-web-service.production.svc.cluster.local:8080

# Health Endpoints (implemented by application):
# - GET /health → 200 OK (liveness probe)
# - GET /ready → 200 OK if database, external services are reachable (readiness probe)

# Deployment Instructions:
# 1. Ensure all prerequisites exist (secrets, image pull secret, Gateway)
# 2. Validate claim: ./scripts/validate-claim.sh full-claim.yaml
# 3. Apply claim: kubectl apply -f full-claim.yaml
# 4. Check status: kubectl get webservice full-featured-web-service -n production
# 5. Verify database: kubectl get postgresinstance full-featured-web-service-db -n production
# 6. Test external access: curl https://api.bizmatters.com/v1/health

# Troubleshooting:
# - ImagePullBackOff: Check ghcr-pull-secret exists and is valid
# - CreateContainerConfigError: Check all 3 secrets exist
# - Init:CrashLoopBackOff: Check database is reachable, migrations script is correct
# - HTTPRoute not working: Check cilium-gateway exists, DNS resolves to cluster