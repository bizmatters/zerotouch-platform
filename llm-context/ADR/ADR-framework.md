# ZeroTouch Platform: Architecture Decision Framework

## 1. Purpose
This document serves as the **primary filter** for all architectural decisions. When adding features, debugging issues, or designing new pipelines, check your plan against these principles. If a plan violates these rules, it must be rejected or redesigned.

## 2. The Core Heuristic: "The Solo Founder Test"
**Question:** *"If I implement this, will it wake me up at 3 AM?"*

*   **Reject:** Anything requiring manual maintenance, OS patching, or "remembering" to run a command.
*   **Accept:** Self-healing systems, declarative configs, and "crash-only" recovery.

## 3. Decision Matrix: "Where does logic live?"

When adding functionality, place it according to this strict hierarchy:

| Task Type | The Tool | The Rule | Anti-Pattern (Forbidden) |
| :--- | :--- | :--- | :--- |
| **Day 0 (Bootstrap)** | **Bash Scripts** | Only for creating the Cluster, Etcd, and CNI. | Moving bootstrap logic to Crossplane (creates Chicken/Egg problem). |
| **Infra Provisioning** | **Crossplane** | DBs, Caches, Buckets, IAM. Must be an XRD. | Using Terraform or clicking in AWS Console. |
| **App Deployment** | **ArgoCD** | Syncs `zerotouch-tenants` to Cluster. | Running `kubectl apply` in a CD pipeline. |
| **App Configuration** | **Filesystem** | `ci/config.yaml` is the contract. | Hardcoding env vars in pipeline scripts. |
| **Secrets** | **AWS SSM** | Source of Truth is SSM. Synced via ESO. | `.env` files in Git or manual `kubectl create secret`. |
| **Observability** | **GitOps** | Dashboards/Alerts defined as Code. | Editing Grafana dashboards in the UI. |

## 4. The "State" Laws

### Law 1: GitOps is the Only Writer
*   **Rule:** The CI/CD pipeline's ONLY job is to **modify files in Git**.
*   **Implication:** A deployment script must `git commit` a new image tag. It must NEVER `kubectl set image`.
*   **Why:** If the cluster crashes, we must be able to restore the exact state from Git. Direct kubectl changes are lost.

### Law 2: The OS is Immutable
*   **Rule:** We use Talos Linux. There is no SSH. There is no package manager.
*   **Implication:** If a node is acting up, we **reboot it**. If that fails, we **replace it**. We never "log in to fix it."

### Law 3: Data Gravity
*   **Rule:** Stateless apps are cattle. Databases are pets, but managed by robots.
*   **Implication:** We use CloudNativePG. We always test "Point-in-Time Recovery" (PITR).
*   **Constraint:** A service is not "Production Ready" until its data backup has been successfully restored in a test.

## 5. Implementation Patterns

### The "Service Contract" Pattern
Do not build custom pipelines for services.
*   **Correct:** The Platform provides a generic pipeline (`in-cluster-test.sh`). The Service provides a config (`ci/config.yaml`).
*   **Incorrect:** A service repo containing its own `build.sh` or `deploy.sh`.

### The "Hybrid Secret" Pattern
*   **DB Credentials:** Generated by Crossplane/CNPG inside the cluster. (We don't need to know them).
*   **3rd Party Keys (OpenAI/Stripe):** Stored in AWS SSM, synced via ESO.
*   **Result:** Applications simply mount `secretKeyRef`. They don't care where the secret came from.

### The "Preview vs. Production" Pattern
We do not mock infrastructure; we change the *mode* of the infrastructure.
*   **Production:** Bare-metal, Cilium, Persistent Storage, Multi-node.
*   **Preview:** Kind, Kindnet, Ephemeral Storage, Single-node.
*   **Rule:** Logic scripts must remain identical. Only the `bootstrap` flags change.

## 6. How to Resolve Conflict

**Scenario:** A new requirement makes it hard to follow "Zero-Touch."
*   **Example:** "I need to run a one-off database migration script manually."
*   **Resolution:** Do not run it manually. Wrap it in a Kubernetes `Job`. Commit the Job to Git. Let ArgoCD run it.
*   **Why:** History. If it's in Git, we know it ran. If you ran it in a terminal, it's lost knowledge.