# Service CI Contract

## Overview

The platform provides a centralized `in-cluster-test.sh` script that services consume through a **filesystem contract**. Services publish data in standardized locations, and the platform owns execution.

**Core Principle:** Platform scripts consume a contract, not arguments.

## Service CI Contract

A service is CI-compatible if it follows this filesystem layout:

### Required Structure

```
service-repo/
├── ci/
│   └── config.yaml              # Required: All service configuration
├── platform/
│   └── claims/<namespace>/      # Required: Kubernetes manifests (with production-ready image references)
├── patches/                     # Required: If ci/config.yaml declares internal dependencies
│   ├── 01-downsize-postgres.sh # Required: If postgres in dependencies.internal
│   └── 02-optimize-resources.sh # Required: Resource optimization for Kind
└── Dockerfile                   # Required: Service container build instructions
```

**CRITICAL RULE**: If `ci/config.yaml` declares any `dependencies.internal` services (postgres, redis, etc.), the service MUST provide corresponding patches in `patches/` directory. These patches adapt the service for Kind/preview environments during CI testing.

### Optional Structure

```
service-repo/
├── migrations/                  # Optional: Database migration files
│   ├── 001_initial.up.sql
│   └── 002_add_users.up.sql
└── tests/
    └── integration/             # Optional: Integration test files
        ├── test_api.py
        └── test_db.py
```

## Configuration Files

### 1. `ci/config.yaml` (Required)

```yaml
service:
  name: "deepagents-runtime"
  namespace: "intelligence-deepagents"
  
build:
  dockerfile: "Dockerfile"  # Default: ./Dockerfile
  context: "."             # Default: .
  tag: "ci-test"          # Default: ci-test
  
test:
  timeout: 600             # Default: 600 seconds
  parallel: true           # Default: true
  
deployment:
  wait_timeout: 300        # Default: 300 seconds
  health_endpoint: "/ready" # Default: /ready
  liveness_endpoint: "/health" # Default: /health
  
# Platform enforced standards - services must comply
dependencies:
  - postgres              # Platform will provision PostgreSQL
  - redis                # Platform will provision Redis/Dragonfly  
  - deepagents-runtime   # Platform will setup this dependency

# Environment variables for CI
env:
  USE_MOCK_LLM: "true"
  LOG_LEVEL: "debug"
  
# Secret requirements - platform enforces naming convention
secrets:
  database: true          # Creates <service>-db-conn secret
  cache: true            # Creates <service>-cache-conn secret  
  llm_keys: true         # Creates <service>-llm-keys secret

# Diagnostic configuration
diagnostics:
  pre_deploy:
    check_dependencies: true
    check_platform_apis: true
  post_deploy:
    test_health_endpoint: true
    test_database_connection: true
    test_service_connectivity: true
```

### 2. `env/ci.env` (Optional)

```bash
# Service-specific environment variables for CI
USE_MOCK_LLM=true
LOG_LEVEL=debug
FEATURE_FLAGS=experimental_api,new_ui
```

### 3. `secrets/requirements.yaml` (Optional)

```yaml
secrets:
  - name: "db-conn"
    keys: ["POSTGRES_HOST", "POSTGRES_USER", "POSTGRES_PASSWORD", "POSTGRES_DB"]
  - name: "cache-conn" 
    keys: ["DRAGONFLY_HOST", "DRAGONFLY_PASSWORD"]
  - name: "llm-keys"
    keys: ["OPENAI_API_KEY", "ANTHROPIC_API_KEY"]
```

### 2. Platform Standards (Enforced)

**Health Endpoints:** All services MUST implement:
- `/health` - Liveness probe (configurable via `liveness_endpoint`)
- `/ready` - Readiness probe (configurable via `health_endpoint`)

**Secret Naming:** Platform auto-generates secrets based on dependencies:
- `<service-name>-db-conn` - Database connection (when `postgres` dependency)
- `<service-name>-cache-conn` - Cache connection (when `redis` dependency)
- `<service-name>-llm-keys` - LLM API keys (auto-generated by platform)

**Environment Variables:** Platform sets standard variables based on dependencies:
- `POSTGRES_HOST`, `POSTGRES_USER`, `POSTGRES_PASSWORD`, `POSTGRES_DB` (postgres dependency)
- `DRAGONFLY_HOST`, `DRAGONFLY_PASSWORD` (redis dependency)
- `OPENAI_API_KEY`, `ANTHROPIC_API_KEY` (auto-generated)

**Dependencies:** Platform supports standard dependencies:
- `postgres` - Provisions PostgreSQL cluster via platform claims
- `redis` - Provisions Redis/Dragonfly cache via platform claims
- `deepagents-runtime` - Sets up deepagents-runtime service

## Platform Build System

The platform provides a centralized build system that automatically detects the environment and builds appropriate images.

### Build Modes (Auto-Detected)

| Mode | Environment Detection | Image Built | Registry Push | Use Case |
|------|----------------------|-------------|---------------|----------|
| `test` | Local execution | `service:ci-test` | ❌ No (Kind only) | Local CI, developer testing |
| `pr` | GitHub Actions + PR | `ghcr.io/org/service:branch-sha` | ✅ Yes | PR testing, staging |
| `prod` | GitHub Actions + main | `ghcr.io/org/service:latest` + `main-sha` | ✅ Yes | Production deployment |

### Image Strategy

**Git Repository (Default State):**
```yaml
# platform/claims/namespace/service-deployment.yaml
spec:
  image: service:latest  # Production-ready default
```

**CI Patching (Temporary):**
- **Local CI:** Patches to `service:ci-test` (built and loaded into Kind)
- **PR CI:** Patches to `ghcr.io/org/service:branch-sha` (pushed to registry)
- **Production:** Uses default `service:latest` (no patching needed)

**Benefits:**
- Git always contains production-ready configuration
- No registry dependencies for local development
- Automatic environment detection
- Consistent across all services

### Platform Scripts

The platform automatically:
1. **Detects environment** (local vs GitHub Actions, PR vs main branch)
2. **Builds appropriate image** based on detected mode
3. **Patches deployment manifests** to use correct image
4. **Deploys service** using patched manifests

Services only need to provide:
- `Dockerfile` for building the service
- `ci/config.yaml` for configuration
- `platform/claims/` with production-ready image references

The platform's `in-cluster-test.sh` script discovers inputs by location and uses boolean flags to control behavior:

```bash
# Auto-discovery pattern
if [ -f ci/config.yaml ]; then load_service_config; fi
if [ -d migrations/ ]; then run_migrations; fi
if [ -d tests/integration ]; then run_tests; fi
if [ -d patches/ ]; then apply_patches; fi

# Config-controlled behavior
if config_enabled "diagnostics.pre_deploy.check_dependencies"; then
    check_service_dependencies
fi

if config_enabled "diagnostics.post_deploy.test_health_endpoint"; then
    test_standard_health_endpoints
fi
```

### Platform Standards Enforcement

**Dependencies (Standardized Setup):**
- `postgres` → Platform provisions PostgreSQL cluster via claims
- `redis` → Platform provisions Redis/Dragonfly cache via claims  
- `deepagents-runtime` → Platform clones, builds, and deploys service
- Each dependency follows standard setup patterns

**Pre-Deploy Diagnostics (Flag-Controlled):**
- `check_dependencies: true` → Validates each dependency from config list is healthy
- `check_platform_apis: true` → Checks required XRDs and compositions exist
- Platform uses standard checks for all services

**Post-Deploy Diagnostics (Flag-Controlled):**
- `test_health_endpoint: true` → Tests standard `/health` and `/ready` endpoints
- `test_database_connection: true` → Tests DB connectivity using standard secrets
- `test_service_connectivity: true` → Tests service accessibility via cluster IP
- Platform enforces standard endpoint patterns

## Service Usage

Services call the platform script without arguments:

```bash
#!/bin/bash
# service-repo/scripts/local/ci/run-integration-tests.sh

# Clone platform if needed
if [[ ! -d "zerotouch-platform" ]]; then
    git clone https://github.com/arun4infra/zerotouch-platform.git
fi

# Run centralized script (no arguments needed)
./zerotouch-platform/scripts/bootstrap/preview/tenants/in-cluster-test.sh
```

## Migration Guide

### From Current Pattern

**Before (Arguments):**
```bash
./in-cluster-test.sh \
    --service="deepagents-runtime" \
    --test-path="tests/integration/" \
    --test-name="integration-tests" \
    --namespace="intelligence-deepagents"
```

**After (Filesystem Contract):**
```bash
# Create ci/config.yaml with service configuration
# Run without arguments
./in-cluster-test.sh
```

### Steps to Migrate

1. **Create `ci/config.yaml`** with service configuration
2. **Move migrations** to `migrations/` directory
3. **Move tests** to `tests/integration/` directory  
4. **Create `env/ci.env`** for environment variables
5. **Remove service CI scripts** (they're now centralized)
6. **Update service CI calls** to use platform script without arguments

## Validation

The platform validates service compliance:

```bash
# Required files/directories
✓ ci/config.yaml exists
✓ platform/claims/<namespace>/ exists
✓ patches/ exists (if dependencies.internal declared in ci/config.yaml)
✓ No scripts under scripts/ci/ (removed)

# Optional validation
✓ migrations/ contains valid SQL files
✓ tests/integration/ contains test files
✓ env/ci.env has valid environment variables

# Internal dependencies validation
✓ patches/01-downsize-postgres.sh exists (if postgres in dependencies.internal)
✓ patches/02-optimize-resources.sh exists (if redis in dependencies.internal)
```

## Benefits

- **No argument parsing** - Platform discovers everything from filesystem
- **Convention over configuration** - Standard locations for everything
- **Service autonomy** - Services control their data, platform controls execution
- **Easy validation** - Check file existence, not argument parsing
- **Human readable** - Clear filesystem layout shows service capabilities

## What Platform Teams Do NOT Do

❌ Require flags like `--namespace`  
❌ Let services ship executable CI scripts  
❌ Allow service-defined secrets  
❌ Duplicate infra metadata in CI  
❌ Make CI depend on platform repos  
❌ Let services define their own health endpoints  
❌ Allow custom secret naming conventions  
❌ Support non-standard dependency types  

## Platform Standards Enforcement

✅ **Standard Health Endpoints**: All services must implement `/health` and `/ready`  
✅ **Standard Secret Names**: Platform enforces `<service>-db-conn` pattern  
✅ **Standard Environment Variables**: Platform sets consistent variable names  
✅ **Standard Dependencies**: Platform supports only `postgres`, `redis`, `deepagents-runtime`  
✅ **Standard Deployment Labels**: Platform uses consistent Kubernetes labels  
✅ **Standard Diagnostic Checks**: Platform runs same checks for all services  

## Examples

### Minimal Service (API only)
```
service-repo/
├── ci/config.yaml
└── platform/claims/intelligence-myservice/
```

**ci/config.yaml:**
```yaml
service:
  name: "my-service"
  namespace: "intelligence-myservice"

dependencies: []

diagnostics:
  pre_deploy:
    check_platform_apis: true
  post_deploy:
    test_health_endpoint: true
    test_service_connectivity: true
```

### Full Service (Database + Tests + Dependencies)
```
service-repo/
├── ci/config.yaml
├── migrations/
├── tests/integration/
├── patches/
└── platform/claims/intelligence-myservice/
```

**ci/config.yaml:**
```yaml
service:
  name: "my-service"
  namespace: "intelligence-myservice"

dependencies:
  - postgres
  - redis
  - deepagents-runtime

env:
  USE_MOCK_LLM: "true"
  LOG_LEVEL: "debug"

secrets:
  database: true
  cache: true
  llm_keys: true

diagnostics:
  pre_deploy:
    check_dependencies: true
    check_platform_apis: true
  post_deploy:
    test_health_endpoint: true
    test_database_connection: true
    test_service_connectivity: true
```

### Service During Migration (Legacy Support)
```
service-repo/
├── ci/config.yaml              # New standard
├── scripts/ci/                 # Remove after migration
└── platform/claims/intelligence-myservice/
```

This contract ensures services are CI-compatible while giving the platform full control over execution strategy.